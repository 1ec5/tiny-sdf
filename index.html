<!DOCTYPE html>
<html>
<head>
<title>TinySDF demo</title>
<meta charset="utf8" />
<style>
body { font: 14px/1 Helvetica, Arial, sans-serif; margin: 0; padding: 0; }
#container { width: 1000px; margin: 0 auto; }
input { width: 880px; }
label { font-weight: bold; width: 90px; display: inline-block; }
a { color: #0af; }
#log { margin: 0; }
</style>
</head>
<body>

<div id="container">
    <h1><a href="https://github.com/mapbox/tiny-sdf">TinySDF</a> demo</h1>
    <p>
        <label>Font size</label> <input id="fontsize" type="range" min="16" max="104" step="8" value="24">
        <label>Font weight</label> <input id="fontweight" type="range" min="100" max="900" step="100" value="400">
    </p>
    <canvas id="canvas" width="1000" height="400"></canvas>
    <p id="log"></p>
    <p>
        <label>Size</label> <input type="range" value="128" step="0.01" min="16" max="256.0" id="scale">
        <label>Halo</label> <input type="range" value="0.55" step="0.01" min="0.4" max="0.9" id="halo">
        <label>Angle</label> <input type="range" value="0" step="0.01" min="-0.1" max="0.1" id="angle">
        <label>Gamma</label> <input type="range" value="2" step="0.01" min="0" max="4" id="gamma">
    </p>
    <canvas id="canvas2" width="1000" height="100"></canvas>
</div>

<script type="module">

import {mat4} from 'https://cdn.skypack.dev/pin/gl-matrix@v3.3.0-QDHIgv9E54Kj6suUMV0n/mode=imports,min/optimized/gl-matrix.js';
import TinySDF from './index.js';

const chars = 'ğŸ‡¦ğŸ‡¶Äà¤•à¥à¤·à¤¿ğŸ¦½ğŸ‘©ğŸ½â€ğŸ¦½ğŸ˜ğ¢„‚ğ¡”–åŸæ³½æç­é€è«ç¬”äº¡é²œè¯åœ£æ‹©å¯»å‚ç¡åšå‹’çƒŸæˆè¯ºä¼¦å²¸å¥¥å”å–ä¿„ç‚¸è½½æ´›å¥å ‚æ—å®«å–å€Ÿå›ç¦é˜´å›­è°‹å®‹é¿æŠ“è£å§‘å­™é€ƒç‰™æŸè·³é¡¶ç‰é•‡é›ªåˆç»ƒè¿«çˆ·ç¯‡è‚‰å˜´é¦†éå‡¡ç¡€æ´å·å¦ç‰›å®çº¸è¯¸è®­ç§åº„ç¥–ä¸ç¿»æš´æ£®å¡”é»˜æ¡æˆéšç†Ÿéª¨è®¿å¼±è’™æ­Œåº—é¬¼è½¯å…¸æ¬²è¨ä¼™é­ç›˜çˆ¸æ‰©ç›–å¼„é›„ç¨³å¿˜äº¿åˆºæ‹¥å¾’å§†æ¨é½èµ›è¶£æ›²åˆ€åºŠè¿å†°è™šç©æçª—é†’å¦»é€è´­æ›¿å¡åŠªä¼‘è™æ‰¬é€”ä¾µåˆ‘ç»¿å…„è¿…å¥—è´¸æ¯•å”¯è°·è½®åº“è¿¹å°¤ç«è¡—ä¿ƒå»¶éœ‡å¼ƒç”²ä¼Ÿéº»å·ç”³ç¼“æ½œé—ªå”®ç¯é’ˆå“²ç»œæŠµæœ±åŸƒæŠ±é¼“æ¤çº¯å¤å¿é¡µæ°ç­‘æŠ˜éƒ‘è´å°Šå´ç§€æ··è‡£é›…æŒ¯æŸ“ç››æ€’èˆåœ†æç‹‚æªå§“æ®‹ç§‹åŸ¹è¿·è¯šå®½å®‡çŒ›æ‘†æ¢…æ¯ä¼¸æ‘©ç›Ÿæœ«ä¹ƒæ‚²æ‹ä¸èµµç¡¬éº¦è’‹æ“è€¶é˜»è®¢å½©æŠ½èµé­”çº·æ²¿å–Šè¿å¦¹æµªæ±‡å¸ä¸°è“æ®ŠçŒ®æ¡Œå•¦ç“¦è±æ´è¯‘å¤ºæ±½çƒ§è·è£åç¬¦å‹‡è§¦è¯¾æ•¬å“­æ‡‚å¢™è¢­å¬ç½šä¾ å…æ‹œå·§ä¾§éŸ©å†’å€ºæ›¼èæƒ¯äº«æˆ´ç«¥çŠ¹ä¹˜æŒ‚å¥–ç»åšçºµéšœè®¯æ¶‰å½»åˆŠä¸ˆçˆ†ä¹Œå½¹ææ´—ç›æ‚£å¦™é•œå”±çƒ¦ç­¾ä»™å½¼å¼—ç—‡ä»¿å€¾ç‰Œé™·é¸Ÿè½°å’±èœé—­å¥‹åº†æ’¤æ³ªèŒ¶ç–¾ç¼˜æ’­æœ—æœå¥¶å­£ä¸¹ç‹—å°¾ä»ªå·å¥”ç è™«é©»å­”å®œè‰¾æ¡¥æ·¡ç¿¼æ¨ç¹å¯’ä¼´å¹æ—¦æ„ˆæ½®ç²®ç¼©ç½¢èšå¾„æ°æŒ‘è¢‹ç°æ•å¾çå¹•æ˜ è£‚æ³°éš”å¯å°–å¿ ç´¯ç‚æš‚ä¼°æ³›è’å¿æ¨ªæ‹’ç‘å¿†å­¤é¼»é—¹ç¾Šå‘†å‰è¡¡èƒé›¶ç©·èˆç èµ«å©†é­‚ç¾æ´ªè…¿èƒ†æ´¥ä¿—è¾©èƒ¸æ™“åŠ²è´«ä»å¶è¾‘é‚¦æ¢èµ–åœˆæ‘¸ä»°æ¶¦å †ç¢°è‰‡ç¨è¿Ÿè¾†åºŸå‡€å‡¶ç½²å£å¾¡å¥‰æ—‹å†¬çŸ¿æŠ¬è›‹æ™¨ä¼å¹é¸¡å€ç³Šç§¦ç›¾æ¯ç§Ÿéª‘ä¹éš†è¯Šå¥´æ‘„ä¸§æ±¡æ¸¡æ——ç”˜è€å‡­æ‰æŠ¢ç»ªç²—è‚©æ¢å¹»è²çš†ç¢å®™å”å²©è¡ç»¼çˆ¬è·æ‚‰è’‚è¿”äº•å£®è–„æ‚„æ‰«æ•ç¢æ®–è¯¦è¿ªçŸ›éœå…å¹…æ’’å‰©å‡¯é¢—éª‚èµæ¶²ç•ªç®±è´´æ¼«é…¸éƒè…°èˆ’çœ‰å¿§æµ®è¾›æ‹é¤å“æŒºåŠ±è¾è‰˜é”®ä¼å³°å°ºæ˜¨é»è¾ˆè´¯ä¾¦æ»‘åˆ¸å´‡æ‰°å®ªç»•è¶‹æ…ˆä¹”é˜…æ±—ææ‹–å¢¨èƒæ’ç®­è…Šç²‰æ³¥æ°å½­æ‹”éª—å‡¤æ…§åª’ä½©æ„¤æ‰‘é¾„é©±æƒœè±ªæ©å…¼è·ƒå°¸è‚ƒå¸•é©¶å ¡å±Šæ¬£æƒ å†Œå‚¨é£˜æ¡‘é—²æƒ¨æ´è¸ªå‹ƒå®¾é¢‘ä»‡ç£¨é€’é‚ªæ’æ‹Ÿæ»šå¥å·¡é¢œå‰‚ç»©è´¡ç–¯å¡ç§æˆªç‡ƒç„¦æ®¿ä¼ªæŸ³é”é€¼é¢‡æ˜åŠå‘ˆæœå‹¤æˆ’é©¾æ¼‚é¥®æ›¹æœµä»”æŸ”ä¿©å­Ÿè…å¹¼è·µç±ç‰§å‡‰ç‰²ä½³å¨œæµ“èŠ³ç¨¿ç«¹è…¹è·Œé€»å‚éµè„‰è²ŒæŸç‹±çŒœæ€œæƒ‘é™¶å…½å¸é¥°è´·æ˜Œå™èººé’¢æ²Ÿå¯„æ‰¶é“ºé‚“å¯¿æƒ§è¯¢æ±¤ç›—è‚¥å°åŒ†è¾‰å¥ˆæ‰£å»·æ¾³å˜›è‘£è¿å‡æ…°åŒè„è…¾å¹½æ€¨é‹ä¸¢åŸ‹æ³‰æ¶Œè¾–èº²æ™‹ç´«è‰°é­å¾æ…Œç¥é‚®åç‹ é‰´æ›°æ¢°å’¬é‚»èµ¤æŒ¤å¼¯æ¤…é™ªå‰²æ­éŸ¦æ‚Ÿèªé›¾é”‹æ¢¯çŒ«ç¥¥é˜”èª‰ç­¹ä¸›ç‰µé¸£æ²ˆé˜ç©†å±ˆæ—¨è¢–çŒè‡‚è›‡è´ºæŸ±æŠ›é¼ ç‘Ÿæˆˆç‰¢é€Šè¿ˆæ¬ºå¨ç´è¡°ç“¶æ¼ç‡•ä»²è¯±ç‹¼æ± ç–¼å¢ä»—å† ç²’é¥å•ç„å°˜å†¯æŠšæµ…æ•¦çº é’»æ™¶å²‚å³¡è‹å–·è€—å‡Œæ•²èŒèµ”æ¶‚ç²¹æ‰äºå¯‚ç…¤ç†Šæ­æ¹¿å¾ªæš–ç³–èµ‹æŠ‘ç§©å¸½å“€å®¿è¸çƒ‚è¢ä¾¯æŠ–å¤¹æ˜†è‚æ“¦çŒªç‚¼æ’æ…æ¬çº½çº¹ç»æ¸”ç£é“œé½¿è·¨æŠ¼æ€–æ¼ ç–²å›é£å…¹ç¥­é†‰æ‹³å¼¥æ–œæ¡£ç¨€æ·è‚¤ç–«è‚¿è±†å‰Šå²—æ™ƒåå®ç™Œè‚šéš¶å±¥æ¶¨è€€æ‰­å›æ‹¨æ²ƒç»˜ä¼å ªä»†éƒ­ç‰ºæ­¼å¢“é›‡å»‰å¥‘æ‹¼æƒ©æ‰è¦†åˆ·åŠ«å«Œç“œæ­‡é›•é—·ä¹³ä¸²å¨ƒç¼´å”¤èµ¢è²éœ¸æ¡ƒå¦¥ç˜¦æ­èµ´å²³å˜‰èˆ±ä¿Šå€åºè€•é”ç¼æ‚”é‚€ç²æƒŸæ–¥å®…æ·»æŒ–å‘µè®¼æ°§æµ©ç¾½æ–¤é…·æ å¦–ç¥¸ä¾ä¹™å¦¨è´ªæŒ£æ±ªå°¿è‰æ‚¬å”‡ç¿°ä»“è½¨æšç›è§ˆå‚…å¸…åº™èŠ¬å±å¯ºèƒ–ç’ƒæ„šæ»´ç–è§å§¿é¢¤ä¸‘åŠ£æŸ¯å¯¸æ‰”ç›¯è¾±åŒ¹ä¿±è¾¨é¥¿èœ‚å“¦è…”éƒæºƒè°¨ç³Ÿè‘›è‹—è‚ å¿Œæºœé¸¿çˆµé¹é¹°ç¬¼ä¸˜æ¡‚æ»‹èŠæŒ¡çº²è‚ŒèŒ¨å£³ç—•ç¢—ç©´è†€å“è´¤å§è†œæ¯…é”¦æ¬ å“©å‡½';

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const segmenter = new Intl.Segmenter();

const sdfs = {};

// Convert alpha-only to RGBA so we can use `putImageData` for building the composite bitmap
function makeRGBAImageData(alphaChannel, width, height) {
    const imageData = ctx.createImageData(width, height);
    for (let i = 0; i < alphaChannel.length; i++) {
        imageData.data[4 * i + 0] = alphaChannel[i];
        imageData.data[4 * i + 1] = alphaChannel[i];
        imageData.data[4 * i + 2] = alphaChannel[i];
        imageData.data[4 * i + 3] = 255;
    }
    return imageData;
}

function updateSDF() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const fontSize = +document.getElementById('fontsize').value;
    const fontWeight = +document.getElementById('fontweight').value;
    const fontStyle = 'normal';
    const buffer = Math.ceil(fontSize / 8);
    const radius = Math.ceil(fontSize / 3);
    const sdf = new TinySDF({fontSize, buffer, radius, fontWeight, fontStyle});
    const size = fontSize + buffer * 2;

    const now = performance.now();
    const segments = segmenter.segment(chars)[Symbol.iterator]();
    let i = 0;
    let segment = segments.next();
    for (let y = 0; y + size <= canvas.height && !segment.done; y += size) {
        for (let x = 0; x + size <= canvas.width && !segment.done; x += size) {
            const {data, width, height} = sdf.draw(segment.value.segment);
            ctx.putImageData(makeRGBAImageData(data, width, height), x, y);
            sdfs[segment.value.segment] = {x, y};
            i++;
            segment = segments.next();
        }
    }
    document.getElementById('log').innerHTML = `${i} characters (${fontSize}px, font-weight: ${fontWeight} with ${buffer}px buffer) rendered in ${Math.round(performance.now() - now)}ms.`;
}

const canvas2 = document.getElementById('canvas2');

if (window.devicePixelRatio > 1) {
    canvas2.style.width = `${canvas2.width}px`;
    canvas2.style.height = `${canvas2.height}px`;
    canvas2.width *= 2;
    canvas2.height *= 2;
}

const gl = canvas2.getContext('webgl', {antialias: false});
if (!gl) {
    alert('Failed to initialize WebGL');
}

const vertexSource = `
    attribute vec2 a_pos;
    attribute vec2 a_texcoord;

    uniform mat4 u_matrix;
    uniform vec2 u_texsize;

    varying vec2 v_texcoord;

    void main() {
        gl_Position = u_matrix * vec4(a_pos.xy, 0, 1);
        v_texcoord = a_texcoord / u_texsize;
    }`;

const fragmentSource = `
    precision mediump float;

    uniform sampler2D u_texture;
    uniform vec4 u_color;
    uniform float u_buffer;
    uniform float u_gamma;

    varying vec2 v_texcoord;

    void main() {
        float dist = texture2D(u_texture, v_texcoord).r;
        float alpha = smoothstep(u_buffer - u_gamma, u_buffer + u_gamma, dist);
        gl_FragColor = vec4(u_color.rgb, alpha * u_color.a);
    }`;

const shader = createProgram(gl, vertexSource, fragmentSource);

gl.useProgram(shader.program);
gl.enableVertexAttribArray(shader.a_pos);
gl.enableVertexAttribArray(shader.a_texcoord);

const pMatrix = mat4.create();
mat4.ortho(pMatrix, 0, gl.canvas.width, gl.canvas.height, 0, 0, -1);

gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
gl.enable(gl.BLEND);

const texture = gl.createTexture();

const vertexBuffer = gl.createBuffer();
const textureBuffer = gl.createBuffer();

const str = 'æ³½æç­é€è«ç¬”äº¡é²œè¯åœ£æ‹©å¯»å‚ç¡åšğŸ‡¦ğŸ‡¶ğŸ‘©ğŸ½â€ğŸ¦½ğŸ˜';

function drawText(size) {
    const vertexElements = [];
    const textureElements = [];

    const fontsize = +document.getElementById('fontsize').value;
    const buf = fontsize / 8;
    const width = fontsize + buf * 2; // glyph width
    const height = fontsize + buf * 2; // glyph height
    const bx = 0; // bearing x
    const by = fontsize / 2 + buf; // bearing y
    const advance = fontsize; // advance

    const scale = size / fontsize;
    const lineWidth = [...str].length * fontsize * scale;

    const pen = {x: canvas2.width / 2 - lineWidth / 2, y: canvas2.height / 2};
    for (const {segment} of segmenter.segment(str)) {
        const posX = sdfs[segment].x; // pos in sprite x
        const posY = sdfs[segment].y; // pos in sprite y

        vertexElements.push(
            pen.x + ((bx - buf) * scale), pen.y - by * scale,
            pen.x + ((bx - buf + width) * scale), pen.y - by * scale,
            pen.x + ((bx - buf) * scale), pen.y + (height - by) * scale,

            pen.x + ((bx - buf + width) * scale), pen.y - by * scale,
            pen.x + ((bx - buf) * scale), pen.y + (height - by) * scale,
            pen.x + ((bx - buf + width) * scale), pen.y + (height - by) * scale
        );

        textureElements.push(
            posX, posY,
            posX + width, posY,
            posX, posY + height,
            posX + width, posY,
            posX, posY + height,
            posX + width, posY + height
        );

        pen.x = pen.x + advance * scale;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexElements), gl.STATIC_DRAW);
    vertexBuffer.numItems = vertexElements.length / 2;

    gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureElements), gl.STATIC_DRAW);
    textureBuffer.numItems = textureElements.length / 2;
}

function drawGL() {
    gl.clearColor(0.8, 0.8, 0.8, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const scale = +document.getElementById('scale').value * window.devicePixelRatio / 2;
    const buffer = +document.getElementById('halo').value;
    const angle = +document.getElementById('angle').value;
    const gamma = +document.getElementById('gamma').value;

    drawText(scale);

    const mvMatrix = mat4.create();
    mat4.translate(mvMatrix, mvMatrix, [canvas2.width / 2, canvas2.height / 2, 0]);
    mat4.rotateZ(mvMatrix, mvMatrix, angle);
    mat4.translate(mvMatrix, mvMatrix, [-canvas2.width / 2, -canvas2.height / 2, 0]);

    const mvpMatrix = mat4.create();
    mat4.multiply(mvpMatrix, pMatrix, mvMatrix);
    gl.uniformMatrix4fv(shader.u_matrix, false, mvpMatrix);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.uniform1i(shader.u_texture, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(shader.a_pos, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
    gl.vertexAttribPointer(shader.a_texcoord, 2, gl.FLOAT, false, 0, 0);

    gl.uniform4fv(shader.u_color, [1, 1, 1, 1]);
    gl.uniform1f(shader.u_buffer, buffer);
    gl.drawArrays(gl.TRIANGLES, 0, vertexBuffer.numItems);

    gl.uniform4fv(shader.u_color, [0, 0, 0, 1]);
    gl.uniform1f(shader.u_buffer, 0.75);
    gl.uniform1f(shader.u_gamma, gamma * 1.4142 / scale);
    gl.drawArrays(gl.TRIANGLES, 0, vertexBuffer.numItems);
}

document.getElementById('fontsize').oninput = frame;
document.getElementById('fontweight').oninput = frame;

document.getElementById('scale').oninput = drawGL;
document.getElementById('halo').oninput = drawGL;
document.getElementById('angle').oninput = drawGL;
document.getElementById('gamma').oninput = drawGL;

let frameId;

function frame() {
    cancelAnimationFrame(frameId);
    frameId = requestAnimationFrame(update);
}

function update() {
    updateSDF();

    const sdfData = new Uint8Array(ctx.getImageData(0, 0, canvas.width, canvas.height).data);

    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, sdfData);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.uniform2f(shader.u_texsize, canvas.width, canvas.height);

    drawGL();
}

update();

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(shader));
    }
    return shader;
}

function createProgram(gl, vertexSource, fragmentSource) {
    const program = gl.createProgram();

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);

    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(program));
    }

    const wrapper = {program};

    const numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < numAttributes; i++) {
        const attribute = gl.getActiveAttrib(program, i);
        wrapper[attribute.name] = gl.getAttribLocation(program, attribute.name);
    }
    const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < numUniforms; i++) {
        const uniform = gl.getActiveUniform(program, i);
        wrapper[uniform.name] = gl.getUniformLocation(program, uniform.name);
    }

    return wrapper;
}
</script>
</body>
</html>
